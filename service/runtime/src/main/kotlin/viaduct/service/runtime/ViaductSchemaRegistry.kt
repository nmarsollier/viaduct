package viaduct.service.runtime

import com.google.inject.Inject
import graphql.GraphQL
import graphql.execution.ExecutionStrategy
import graphql.execution.instrumentation.Instrumentation
import graphql.execution.preparsed.PreparsedDocumentProvider
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentMap
import viaduct.engine.IntrospectionRestrictingPreparsedDocumentProvider
import viaduct.engine.api.ViaductSchema
import viaduct.engine.api.coroutines.CoroutineInterop
import viaduct.service.runtime.SchemaRegistryConfiguration.AsyncScopedSchema

class ViaductSchemaRegistry internal constructor(
    // This is generated by the "registerSchema" that uses the "PublicSchemaRegistration" factories to register the schemas.
    private val scopedSchemas: ConcurrentHashMap<String, ViaductSchema> = ConcurrentHashMap(),
    // These are generated by the "registerSchema" method that allows for lazy loading and using schema compute blocks.  It lazy loads the schema.
    private val asyncScopedSchemas: ConcurrentHashMap<String, AsyncScopedSchema> = ConcurrentHashMap(),
    private val schemaDocumentProvider: ConcurrentHashMap<ViaductSchema, PreparsedDocumentProvider> = ConcurrentHashMap(),
    private val fullSchema: ViaductSchema,
) {
    /**
     * Default implementation of ViaductSchemaRegistryFactory.
     * Gets all necessary dependencies injected and performs the actual registry construction.
     */
    class Factory
        @Inject
        constructor(
            private val coroutineInterop: CoroutineInterop
        ) {
            fun createRegistry(config: SchemaRegistryConfiguration): ViaductSchemaRegistry {
                val info = config.toInfo()

                val fullSchema = info.fullSchema ?: info.graphQLSchemaFactory.createSchema(coroutineInterop)

                val scopedSchemas = ConcurrentHashMap<String, ViaductSchema>()
                val schemaDocumentProvider = ConcurrentHashMap<ViaductSchema, PreparsedDocumentProvider>()

                info.publicSchemaRegistration.forEach {
                    it.buildPublicSchema(fullSchema, coroutineInterop).let { generatedSchema ->
                        scopedSchemas[generatedSchema.schemaId] = generatedSchema.schema
                        schemaDocumentProvider[generatedSchema.schema] = generatedSchema.schemaDocumentProvider
                    }
                }

                // Validate that there are no duplicate schema IDs
                val duplicateKeys = scopedSchemas.keys.intersect(info.asyncSchemaRegistration.keys)
                if (duplicateKeys.isNotEmpty()) {
                    throw IllegalStateException("Duplicate schema IDs found: $duplicateKeys")
                }

                return ViaductSchemaRegistry(
                    scopedSchemas,
                    ConcurrentHashMap(info.asyncSchemaRegistration),
                    schemaDocumentProvider,
                    fullSchema
                )
            }
        }

    private val enginesById: ConcurrentMap<String, Lazy<GraphQLEngine>> = ConcurrentHashMap()
    private val enginesBySchema: ConcurrentMap<ViaductSchema, GraphQLEngine> = ConcurrentHashMap()

    data class GraphQLEngine(
        val schema: ViaductSchema,
        val graphQL: GraphQL
    )

    internal fun registerSchema(
        instrumentation: Instrumentation,
        queryExecutionStrategy: ExecutionStrategy,
        mutationExecutionStrategy: ExecutionStrategy,
        subscriptionExecutionStrategy: ExecutionStrategy,
    ) {
        scopedSchemas.forEach { (id, schema) ->
            registerSchemaInternal(
                id,
                { schema },
                instrumentation,
                { schemaDocumentProvider[schema]!! },
                queryExecutionStrategy,
                mutationExecutionStrategy,
                subscriptionExecutionStrategy
            )
        }

        asyncScopedSchemas.forEach { (id, schema) ->
            registerSchemaInternal(
                id,
                schema.schemaComputeBlock,
                instrumentation,
                schema.documentProviderFactory ?: { CachingPreparsedDocumentProvider() },
                queryExecutionStrategy,
                mutationExecutionStrategy,
                subscriptionExecutionStrategy,
                schema.lazy
            )
        }
    }

    /**
     * Provide access to full schema in schemaRegistry so we don't have to pass ViaductSchemaRegistryBuilder around to get full schema
     * The catch is that it is called before `registerSchema`, aka before schemaRegistry is fully built. Given the immutability
     * of `fullSchema` variable, it's probably still a good compromise.
     */
    fun getFullSchema(): ViaductSchema {
        return fullSchema
    }

    private fun registerSchemaInternal(
        schemaId: String,
        schemaComputeBlock: () -> ViaductSchema,
        instrumentation: Instrumentation,
        documentProviderFactory: ((ViaductSchema) -> PreparsedDocumentProvider),
        queryExecutionStrategy: ExecutionStrategy,
        mutationExecutionStrategy: ExecutionStrategy,
        subscriptionExecutionStrategy: ExecutionStrategy,
        lazy: Boolean = false
    ) {
        enginesById.computeIfAbsent(schemaId) {
            lazy {
                val schema = schemaComputeBlock()
                enginesBySchema.computeIfAbsent(schema) {
                    GraphQLEngine(
                        schema,
                        GraphQL.newGraphQL(schema.schema)
                            .preparsedDocumentProvider(IntrospectionRestrictingPreparsedDocumentProvider(documentProviderFactory(schema)))
                            .queryExecutionStrategy(queryExecutionStrategy)
                            .mutationExecutionStrategy(mutationExecutionStrategy)
                            .subscriptionExecutionStrategy(subscriptionExecutionStrategy)
                            .instrumentation(instrumentation)
                            .build()
                    )
                }
            }
        }.also {
            if (!lazy) {
                it.value
            }
        }
    }

    fun getSchema(schemaId: String): ViaductSchema? = enginesById[schemaId]?.value?.schema

    fun getEngine(schemaId: String): GraphQL? = enginesById[schemaId]?.value?.graphQL
}
